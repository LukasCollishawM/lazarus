from __future__ import annotations

from collections import OrderedDict
from pathlib import Path
from typing import Dict, List, Any
import json

HEADER = "// Generated by Lazarus — review carefully before building."

HOOK_HEADER = """#pragma once

#include <Windows.h>

namespace lazarus {

bool install_hooks();
void remove_hooks();

}
"""


class ModGenerator:
    """
    Emits a minimal C++ DLL project with pattern scanning and MinHook placeholders.
    """

    def __init__(self, clean_report: Dict[str, object]) -> None:
        self.report = clean_report

    def generate(self, target_dir: Path) -> Path:
        target_dir = Path(target_dir)
        src_dir = target_dir / "src"
        src_dir.mkdir(parents=True, exist_ok=True)
        (src_dir / "schema").mkdir(exist_ok=True)
        (src_dir / "instrumentation").mkdir(exist_ok=True)

        pointer_patterns: List[Dict[str, str]] = self.report.get("pointerPatterns", [])  # type: ignore[assignment]
        abi_hints: List[Dict[str, object]] = self.report.get("struct_hints", []) or self.report.get("abiHints", [])  # type: ignore[assignment]
        network_functions: List[Dict[str, object]] = self.report.get("networkFunctions", [])  # type: ignore[assignment]
        function_links: List[Dict[str, object]] = self.report.get("functionPayloadLinks", [])  # type: ignore[assignment]
        inferred_fields: List[Dict[str, object]] = self.report.get("inferredPayloadFields", [])  # type: ignore[assignment]
        hooks_dir = src_dir / "hooks"
        hooks_dir.mkdir(exist_ok=True)

        hook_specs = self._build_hook_specs(network_functions, function_links)

        self._write_cmakelists(target_dir)
        self._write_readme(target_dir, abi_hints, hook_specs)
        self._write_logger(src_dir / "logger.h", src_dir / "logger.cpp")
        self._write_pattern_scan(src_dir / "pattern_scan.cpp", pointer_patterns)
        self._write_hooks_header(src_dir / "hooks" / "hooks.h")
        self._write_hooks_file(src_dir / "hooks" / "hooks.cpp", hook_specs)
        self._write_hook_manifest(src_dir / "hooks" / "hook_targets.json", hook_specs)
        self._write_dllmain(src_dir / "dllmain.cpp")
        schema_dir = src_dir / "schema"
        self._write_payload_schema_header(schema_dir / "payload_schema.h", inferred_fields)
        self._write_payload_bridge(
            schema_dir / "payload_bridge.h",
            schema_dir / "payload_bridge.cpp",
            inferred_fields,
        )
        instrumentation_dir = src_dir / "instrumentation"
        export_dir = instrumentation_dir / "export"
        export_dir.mkdir(parents=True, exist_ok=True)
        self._write_instrumentation_header(instrumentation_dir / "packet_logger.h")
        self._write_instrumentation_source(instrumentation_dir / "packet_logger.cpp")
        self._write_export_sink_header(export_dir / "json_sink.h")
        self._write_export_sink_source(export_dir / "json_sink.cpp")
        self._write_injector_files(target_dir / "injector")
        return target_dir

    def _write_cmakelists(self, target_dir: Path) -> None:
        contents = f"""cmake_minimum_required(VERSION 3.20)
project(lazarus_generated_mod LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

add_library(lazarus_generated_mod SHARED
  src/dllmain.cpp
  src/logger.cpp
  src/pattern_scan.cpp
  src/hooks/hooks.cpp
)

target_include_directories(lazarus_generated_mod PRIVATE src)
target_link_libraries(lazarus_generated_mod
  psapi
)

# TODO: Provide MinHook + RapidJSON dependencies similar to hitman-contracts-mod.
"""
        (target_dir / "CMakeLists.txt").write_text(contents, encoding="utf-8")

    def _write_readme(
        self,
        target_dir: Path,
        abi_hints: List[Dict[str, object]],
        hook_specs: List[Dict[str, Any]],
    ) -> None:
        lines = [
            "# Generated Mod Skeleton",
            "",
            "This DLL is intentionally incomplete. Steps:",
            "",
            "1. Add MinHook binaries and update `CMakeLists.txt` accordingly.",
            "2. Replace pattern placeholders inside `pattern_scan.cpp`.",
            "3. Implement actual hooks and integration similar to hitman-contracts-mod.",
            "4. Mirror the backend payload contract described in `../payload_schema.json` "
            "to ensure serialization stays in sync.",
            "",
            "Maintainer link: https://github.com/lukascollishawm",
            "",
            "## Generated hooks",
        ]
        for spec in hook_specs:
            lines.append(
                f"- `{spec['identifier']}` pattern `{spec['pattern']}` score {spec['score']:.2f} "
                f"imports {spec['imports'] or 'n/a'} endpoints {spec.get('endpoint') or 'unknown'}"
            )

        if abi_hints:
            lines.append("")
            lines.append("## ABI Hints (verify manually)")
            for hint in abi_hints[:5]:
                lines.append(
                    f"- {hint.get('function')} @ {hint.get('entryPoint')} "
                    f"(pointerOps={hint.get('pointerOps')}, arrayOps={hint.get('arrayOps')})"
                )
        lines.append("")
        lines.append("## Injector utility")
        lines.append("")
        lines.append(
            "An optional injector sample lives in `injector/`. Build it with CMake and run "
            "`lazarus_injector.exe --pid <pid> --dll path\\to\\lazarus_generated_mod.dll` "
            "to load the DLL into a running process. Review and harden before shipping."
        )
        lines.append("")
        lines.append("## Instrumentation")
        lines.append("")
        lines.append(
            "Instrumentation helpers live in `src/instrumentation/`. Use `packet_logger.h/.cpp` "
            "to log canonical payloads at runtime and pipe them to the replay harness."
        )
        (target_dir / "README.md").write_text("\n".join(lines), encoding="utf-8")

    def _write_payload_schema_header(self, header_path: Path, inferred_fields: List[Dict[str, object]]) -> None:
        lines = [
            HEADER,
            "#pragma once",
            "",
            "#include <string>",
            "#include <vector>",
            "#include <cstdint>",
            "",
            "namespace lazarus {",
            "",
        ]
        registry: "OrderedDict[str, str]" = OrderedDict()
        self._collect_cpp_structs("GeneratedPayload", inferred_fields, registry)
        if not registry:
            lines.append("// No inferred payload schema; update this file once data structures are known.")
        else:
            for definition in registry.values():
                lines.append(definition)
                lines.append("")
        lines.append("} // namespace lazarus")
        header_path.write_text("\n".join(lines), encoding="utf-8")

    def _write_payload_bridge(
        self, header_path: Path, source_path: Path, inferred_fields: List[Dict[str, object]]
    ) -> None:
        header_lines = [
            HEADER,
            "#pragma once",
            "",
            "#include <cstdint>",
            "#include <string>",
            "#include <vector>",
            "",
            "#include \"payload_schema.h\"",
            "",
            "namespace lazarus {",
            "",
            "struct FieldBinding {",
            "    std::string field;",
            "    uintptr_t address = 0;",
            "    size_t size = 0;",
            "};",
            "",
            "struct GamePayloadContext {",
            "    uintptr_t baseAddress = 0;",
            "    std::vector<FieldBinding> bindings;",
            "    GeneratedPayload shadowPayload{};",
            "};",
            "",
            "void EnsureDefaultBindings(GamePayloadContext& ctx);",
            "void ApplyPayloadToContext(const GeneratedPayload& payload, GamePayloadContext& ctx);",
            "void CapturePayloadFromContext(const GamePayloadContext& ctx, GeneratedPayload& payload);",
            "",
            "} // namespace lazarus",
        ]
        header_path.write_text("\n".join(header_lines), encoding="utf-8")

        source_lines = [
            HEADER,
            "#include \"payload_bridge.h\"",
            "#include \"../logger.h\"",
            "",
            "namespace lazarus {",
            "",
            "void EnsureDefaultBindings(GamePayloadContext& ctx) {",
            "    if (!ctx.bindings.empty()) {",
            "        return;",
            "    }",
        ]
        source_lines.extend(self._render_binding_initializers(inferred_fields))
        source_lines.extend(
            [
                "}",
                "",
                "void ApplyPayloadToContext(const GeneratedPayload& payload, GamePayloadContext& ctx) {",
                "    EnsureDefaultBindings(ctx);",
                "    ctx.shadowPayload = payload;",
            ]
        )
        source_lines.extend(self._render_field_assignments(inferred_fields, direction="apply"))
        source_lines.extend(
            [
                "}",
                "",
                "void CapturePayloadFromContext(const GamePayloadContext& ctx, GeneratedPayload& payload) {",
                "    payload = ctx.shadowPayload;",
                "    // TODO: Replace the cached payload with real reads from ctx.baseAddress/bindings.",
            ]
        )
        source_lines.extend(self._render_field_assignments(inferred_fields, direction="capture"))
        source_lines.extend(
            [
                "}",
                "",
                "} // namespace lazarus",
            ]
        )
        source_path.write_text("\n".join(source_lines), encoding="utf-8")

    def _write_hook_manifest(self, manifest_path: Path, hook_specs: List[Dict[str, Any]]) -> None:
        manifest = []
        for spec in hook_specs:
            manifest.append(
                {
                    "identifier": spec["identifier"],
                    "pattern": spec["pattern"],
                    "description": spec["description"],
                    "imports": spec.get("imports"),
                    "endpoint": spec.get("endpoint"),
                    "payloadFields": spec.get("payload_fields", []),
                    "score": spec.get("score", 0.0),
                }
            )
        manifest_path.write_text(json.dumps(manifest, indent=2), encoding="utf-8")

    def _collect_cpp_structs(
        self, struct_name: str, fields: List[Dict[str, object]], registry: "OrderedDict[str, str]"
    ) -> None:
        if struct_name in registry:
            return
        for field in fields[:32]:
            type_hint = (field.get("typeHint") or "").lower()
            children = field.get("children") or []
            if type_hint == "object" and children:
                child_name = self._child_struct_name(struct_name, field.get("name", "field"))
                self._collect_cpp_structs(child_name, children, registry)
            elif type_hint == "array" and children:
                child = children[0]
                child_type = (child.get("typeHint") or "").lower()
                if child_type == "object":
                    child_name = self._child_struct_name(struct_name, f"{field.get('name', 'field')}_item")
                    self._collect_cpp_structs(child_name, child.get("children", []), registry)
        struct_lines = [f"struct {struct_name} {{"]
        if not fields:
            struct_lines.append("    // TODO: populate fields once schema is confirmed.")
        for field in fields[:32]:
            decl = self._cpp_field_declaration(struct_name, field)
            struct_lines.append(f"    {decl};")
        struct_lines.append("};")
        registry[struct_name] = "\n".join(struct_lines)

    def _cpp_field_declaration(self, parent: str, field: Dict[str, object]) -> str:
        name = self._sanitize_cpp_name(field.get("name", "field"))
        cpp_type = self._cpp_field_type(parent, field)
        return f"{cpp_type} {name}"

    def _cpp_field_type(self, parent: str, field: Dict[str, object]) -> str:
        type_hint = (field.get("typeHint") or "").lower()
        children = field.get("children") or []
        if type_hint == "boolean":
            return "bool"
        if type_hint == "number":
            return "int64_t"
        if type_hint == "object" and children:
            child_name = self._child_struct_name(parent, field.get("name", "field"))
            return child_name
        if type_hint == "array":
            return self._cpp_array_type(parent, field, children)
        return "std::string"

    def _cpp_array_type(self, parent: str, field: Dict[str, object], children: List[Dict[str, object]]) -> str:
        if not children:
            element_type = "std::string"
        else:
            child = children[0]
            child_type = (child.get("typeHint") or "").lower()
            if child_type == "object":
                child_name = self._child_struct_name(parent, f"{field.get('name', 'field')}_item")
                element_type = child_name
            elif child_type == "boolean":
                element_type = "bool"
            elif child_type == "number":
                element_type = "int64_t"
            else:
                element_type = "std::string"
        return f"std::vector<{element_type}>"

    def _child_struct_name(self, parent: str, raw_name: str) -> str:
        cleaned = "".join(ch if ch.isalnum() else "_" for ch in raw_name)
        parts = [part for part in cleaned.split("_") if part]
        pascal = "".join(part.capitalize() for part in parts) or "Field"
        return f"{parent}_{pascal}"

    def _sanitize_cpp_name(self, raw_name: str) -> str:
        cleaned = "".join(ch if ch.isalnum() else "_" for ch in raw_name)
        if not cleaned:
            return "field"
        if cleaned[0].isdigit():
            cleaned = f"_{cleaned}"
        return cleaned.lower()

    def _render_binding_initializers(self, fields: List[Dict[str, object]]) -> List[str]:
        lines: List[str] = []
        if not fields:
            lines.append("    // No inferred fields; populate ctx.bindings manually.")
            return lines
        for path, field in self._iter_field_paths(fields):
            label = ".".join(path)
            cpp_type = self._cpp_field_type("GeneratedPayload", field)
            lines.append(
                f"    ctx.bindings.push_back(FieldBinding{{ \"{label}\", 0, sizeof({cpp_type}) }});"
            )
            lines.append(f"    // TODO: Update ctx.bindings.back().address for '{label}'.")
        return lines

    def _render_field_assignments(
        self, fields: List[Dict[str, object]], *, direction: str
    ) -> List[str]:
        lines: List[str] = []
        if not fields:
            lines.append("    (void)ctx;")
            if direction == "apply":
                lines.append("    (void)payload;")
            else:
                lines.append("    (void)payload;")
            lines.append("    // No payload fields detected; nothing to sync.")
            return lines
        for path, field in self._iter_field_paths(fields):
            label = ".".join(path)
            payload_accessor = self._cpp_field_accessor("payload", path)
            if direction == "apply":
                lines.append(f"    // Field: {label}")
                lines.append("    for (const auto& binding : ctx.bindings) {")
                lines.append(
                    f"        if (binding.field == \"{label}\" && binding.address != 0) {{"
                )
                lines.append(
                    f"            // TODO: Copy {payload_accessor} into the memory at binding.address."
                )
                lines.append("            break;")
                lines.append("        }")
                lines.append("    }")
            else:
                lines.append(f"    // Field: {label}")
                lines.append(
                    f"    // TODO: Read live data for '{label}' into ctx.shadowPayload before exporting."
                )
            lines.append("")
        return lines

    def _iter_field_paths(
        self, fields: List[Dict[str, object]], prefix: List[str] | None = None
    ) -> List[tuple[List[str], Dict[str, object]]]:
        results: List[tuple[List[str], Dict[str, object]]] = []
        for field in fields[:32]:
            name = str(field.get("name", "field"))
            current = list(prefix or [])
            current.append(name)
            results.append((current, field))
            children = field.get("children") or []
            if children and (field.get("typeHint") or "").lower() == "object":
                results.extend(self._iter_field_paths(children, current))
        return results

    def _cpp_field_accessor(self, root: str, path: List[str]) -> str:
        accessor = root
        for part in path:
            accessor += f".{self._sanitize_cpp_name(part)}"
        return accessor

    def _sanitize_js_property(self, name: str) -> str:
        if name.isidentifier():
            return name
        return f"[\"{name}\"]"

    def _write_export_sink_header(self, header_path: Path) -> None:
        contents = (
            HEADER
            + """
#pragma once

#include <string>

namespace lazarus {

// Flush packet logs to JSON file and optionally send via HTTP POST.
bool ExportPacketLog(const std::wstring& log_path, const std::wstring& json_path);
bool PostPacketLog(const std::wstring& json_path, const std::wstring& url);

} // namespace lazarus
"""
        )
        header_path.write_text(contents, encoding="utf-8")

    def _write_export_sink_source(self, source_path: Path) -> None:
        contents = (
            HEADER
            + """
#include "json_sink.h"

#include <Windows.h>
#include <winhttp.h>

#include <fstream>
#include <sstream>
#include <vector>

#include "../packet_logger.h"

#pragma comment(lib, "winhttp.lib")

namespace lazarus {

static std::wstring Escape(const std::wstring& value) {
    std::wstring result;
    for (wchar_t ch : value) {
        if (ch == L'"' || ch == L'\\') {
            result.push_back(L'\\');
        }
        result.push_back(ch);
    }
    return result;
}

bool ExportPacketLog(const std::wstring& log_path, const std::wstring& json_path) {
    std::wofstream stream(json_path);
    if (!stream.is_open()) {
        return false;
    }
    stream << L"{\\"meta\\":{\\"source\\":\\"lazarus\\"},\\"requests\\":[";
    auto entries = FlushPacketLog();
    bool first = true;
    for (const auto& entry : entries) {
        if (!first) {
            stream << L",";
        }
        first = false;
        stream << L"{\\"direction\\":\\"" << Escape(entry.direction) << L"\\",";
        stream << L"\\"endpoint\\":\\"" << Escape(entry.endpoint) << L"\\",";
        stream << L"\\"payload\\":\\"" << L"TODO" << L"\\"}";
    }
    stream << L"]}";
    log_info("Packet log exported to JSON sink.");
    return true;
}

bool PostPacketLog(const std::wstring& json_path, const std::wstring& url) {
    std::wifstream stream(json_path);
    if (!stream.is_open()) {
        return false;
    }
    std::wstringstream buffer;
    buffer << stream.rdbuf();
    const std::wstring body = buffer.str();
    HINTERNET session = WinHttpOpen(L"LazarusReplay/1.0", WINHTTP_ACCESS_TYPE_AUTOMATIC_PROXY, nullptr, nullptr, 0);
    if (!session) {
        return false;
    }
    URL_COMPONENTSW components{};
    components.dwStructSize = sizeof(components);
    wchar_t host[256];
    wchar_t path[1024];
    components.lpszHostName = host;
    components.dwHostNameLength = 256;
    components.lpszUrlPath = path;
    components.dwUrlPathLength = 1024;
    if (!WinHttpCrackUrl(url.c_str(), 0, 0, &components)) {
        WinHttpCloseHandle(session);
        return false;
    }
    HINTERNET connection = WinHttpConnect(session, host, components.nPort, 0);
    if (!connection) {
        WinHttpCloseHandle(session);
        return false;
    }
    HINTERNET request = WinHttpOpenRequest(
        connection,
        L"POST",
        path,
        nullptr,
        WINHTTP_NO_REFERER,
        WINHTTP_DEFAULT_ACCEPT_TYPES,
        components.nScheme == INTERNET_SCHEME_HTTPS ? WINHTTP_FLAG_SECURE : 0);
    if (!request) {
        WinHttpCloseHandle(connection);
        WinHttpCloseHandle(session);
        return false;
    }
    bool ok = WinHttpSendRequest(
        request,
        L"Content-Type: application/json\r\n",
        -1,
        (LPVOID)body.c_str(),
        static_cast<DWORD>(body.size() * sizeof(wchar_t)),
        static_cast<DWORD>(body.size() * sizeof(wchar_t)),
        0);
    if (ok) {
        ok = WinHttpReceiveResponse(request, nullptr);
    }
    WinHttpCloseHandle(request);
    WinHttpCloseHandle(connection);
    WinHttpCloseHandle(session);
    return ok;
}

} // namespace lazarus
"""
        )
        source_path.write_text(contents, encoding="utf-8")

    def _write_instrumentation_header(self, header_path: Path) -> None:
        contents = (
            HEADER
            + """
#pragma once

#include <string>
#include <vector>

#include "../schema/payload_schema.h"

namespace lazarus {

struct PacketLogEntry {
    std::string direction;
    std::string endpoint;
    GeneratedPayload payload;
};

void InitPacketLogger(const std::wstring& log_path);
void LogPacket(const PacketLogEntry& entry);
std::vector<PacketLogEntry> FlushPacketLog();

} // namespace lazarus
"""
        )
        header_path.write_text(contents, encoding="utf-8")

    def _write_instrumentation_source(self, source_path: Path) -> None:
        contents = (
            HEADER
            + """
#include "packet_logger.h"

#include <mutex>
#include <fstream>

#include "../logger.h"

namespace {
std::mutex g_packet_mutex;
std::vector<lazarus::PacketLogEntry> g_entries;
std::wstring g_log_path;
}

namespace lazarus {

void InitPacketLogger(const std::wstring& log_path) {
    std::lock_guard<std::mutex> lock(g_packet_mutex);
    g_log_path = log_path;
    g_entries.clear();
    log_info("Packet logger initialized.");
}

void LogPacket(const PacketLogEntry& entry) {
    std::lock_guard<std::mutex> lock(g_packet_mutex);
    g_entries.push_back(entry);
    if (!g_log_path.empty()) {
        std::wofstream stream(g_log_path, std::ios::app);
        stream << L"[lazarus] " << entry.direction.c_str() << L" " << entry.endpoint.c_str() << std::endl;
    }
}

std::vector<PacketLogEntry> FlushPacketLog() {
    std::lock_guard<std::mutex> lock(g_packet_mutex);
    std::vector<PacketLogEntry> copy = g_entries;
    g_entries.clear();
    return copy;
}

} // namespace lazarus
"""
        )
        source_path.write_text(contents, encoding="utf-8")

    def _write_injector_files(self, injector_dir: Path) -> None:
        src_dir = injector_dir / "src"
        src_dir.mkdir(parents=True, exist_ok=True)
        cmake = """cmake_minimum_required(VERSION 3.20)
project(lazarus_injector LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

add_executable(lazarus_injector
  src/injector.cpp
)

target_link_libraries(lazarus_injector
  advapi32
  kernel32
)
"""
        (injector_dir / "CMakeLists.txt").write_text(cmake, encoding="utf-8")

        readme = """# Lazarus Simple Injector

This optional utility demonstrates how to inject `lazarus_generated_mod.dll` into a
running game process. Review and harden it before using outside of a controlled test
environment.

## Build

```
cmake -S . -B build -G "Visual Studio 17 2022" -A x64
cmake --build build --config Release
```

## Usage

```
lazarus_injector.exe --pid 1234 --dll "C:\\path\\to\\lazarus_generated_mod.dll"
```

The target process must already be running. The injector temporarily enables the
`SeDebugPrivilege`, writes the DLL path into the remote process, and asks it to load
the DLL via `LoadLibraryW`.

> ⚠️ **Security**: Keep the injector local-only. Do not distribute binaries that can be
> repurposed for malicious injection.
"""
        (injector_dir / "README.md").write_text(readme, encoding="utf-8")

        src = r"""// Generated by Lazarus — sample DLL injector. Review before use.
#include <Windows.h>
#include <TlHelp32.h>

#include <iostream>
#include <string>

namespace {
bool enable_debug_privilege() {
    HANDLE token = nullptr;
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &token)) {
        return false;
    }
    TOKEN_PRIVILEGES tp{};
    tp.PrivilegeCount = 1;
    LookupPrivilegeValueW(nullptr, L"SeDebugPrivilege", &tp.Privileges[0].Luid);
    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    BOOL ok = AdjustTokenPrivileges(token, FALSE, &tp, sizeof(tp), nullptr, nullptr);
    CloseHandle(token);
    return ok && GetLastError() == ERROR_SUCCESS;
}

bool inject_into_pid(DWORD pid, const std::wstring& dll_path) {
    HANDLE process = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION |
                                     PROCESS_VM_WRITE | PROCESS_VM_READ,
                                 FALSE, pid);
    if (!process) {
        std::wcerr << L"[lazarus] OpenProcess failed: " << GetLastError() << std::endl;
        return false;
    }

    SIZE_T size = (dll_path.size() + 1) * sizeof(wchar_t);
    LPVOID remote_mem = VirtualAllocEx(process, nullptr, size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    if (!remote_mem) {
        std::wcerr << L"[lazarus] VirtualAllocEx failed: " << GetLastError() << std::endl;
        CloseHandle(process);
        return false;
    }

    if (!WriteProcessMemory(process, remote_mem, dll_path.c_str(), size, nullptr)) {
        std::wcerr << L"[lazarus] WriteProcessMemory failed: " << GetLastError() << std::endl;
        VirtualFreeEx(process, remote_mem, 0, MEM_RELEASE);
        CloseHandle(process);
        return false;
    }

    HMODULE kernel32 = GetModuleHandleW(L"kernel32.dll");
    LPTHREAD_START_ROUTINE load_library =
        reinterpret_cast<LPTHREAD_START_ROUTINE>(GetProcAddress(kernel32, "LoadLibraryW"));
    if (!load_library) {
        std::wcerr << L"[lazarus] GetProcAddress failed" << std::endl;
        VirtualFreeEx(process, remote_mem, 0, MEM_RELEASE);
        CloseHandle(process);
        return false;
    }

    HANDLE thread = CreateRemoteThread(process, nullptr, 0, load_library, remote_mem, 0, nullptr);
    if (!thread) {
        std::wcerr << L"[lazarus] CreateRemoteThread failed: " << GetLastError() << std::endl;
        VirtualFreeEx(process, remote_mem, 0, MEM_RELEASE);
        CloseHandle(process);
        return false;
    }

    WaitForSingleObject(thread, INFINITE);
    DWORD exit_code = 0;
    GetExitCodeThread(thread, &exit_code);
    CloseHandle(thread);
    VirtualFreeEx(process, remote_mem, 0, MEM_RELEASE);
    CloseHandle(process);
    return exit_code != 0;
}

void print_usage() {
    std::wcout << L"Usage: lazarus_injector.exe --pid <pid> --dll <path-to-dll>\\n";
}
}  // namespace

int wmain(int argc, wchar_t** argv) {
    DWORD pid = 0;
    std::wstring dll_path;
    for (int i = 1; i < argc; ++i) {
        std::wstring arg = argv[i];
        if ((arg == L"--pid" || arg == L"-p") && i + 1 < argc) {
            pid = static_cast<DWORD>(std::wcstoul(argv[++i], nullptr, 10));
        } else if ((arg == L"--dll" || arg == L"-d") && i + 1 < argc) {
            dll_path = argv[++i];
        } else if (arg == L"--help" || arg == L"-h") {
            print_usage();
            return 0;
        }
    }

    if (pid == 0 || dll_path.empty()) {
        print_usage();
        return 1;
    }

    if (!enable_debug_privilege()) {
        std::wcerr << L"[lazarus] Warning: unable to enable SeDebugPrivilege. Injection may fail.\\n";
    }

    if (!inject_into_pid(pid, dll_path)) {
        std::wcerr << L"[lazarus] Injection failed.\\n";
        return 1;
    }

    std::wcout << L"[lazarus] Injected " << dll_path << L" into PID " << pid << std::endl;
    return 0;
}
"""
        (src_dir / "injector.cpp").write_text(src, encoding="utf-8")

    def _write_logger(self, header_path: Path, src_path: Path) -> None:
        header_path.write_text(
            HEADER
            + """
#pragma once

#include <string>

namespace lazarus {

void log_info(const std::string& msg);
void log_error(const std::string& msg);

}
""",
            encoding="utf-8",
        )

        src_path.write_text(
            HEADER
            + """
#include "logger.h"

#include <Windows.h>
#include <fstream>
#include <mutex>

namespace {
std::mutex g_log_mutex;
std::ofstream& log_stream() {
    static std::ofstream stream("lazarus_mod.log", std::ios::app);
    return stream;
}
}

namespace lazarus {

void log_info(const std::string& msg) {
    std::lock_guard<std::mutex> lock(g_log_mutex);
    log_stream() << "[INFO] " << msg << std::endl;
}

void log_error(const std::string& msg) {
    std::lock_guard<std::mutex> lock(g_log_mutex);
    log_stream() << "[ERROR] " << msg << std::endl;
}

}
""",
            encoding="utf-8",
        )

    def _write_pattern_scan(self, path: Path, pointer_patterns: List[Dict[str, str]]) -> None:
        pattern_lines = [pattern["pattern"] for pattern in pointer_patterns[:10]]
        contents = HEADER + """
#include <Windows.h>
#include <psapi.h>
#include <cstdint>
#include <string>

#include "logger.h"

namespace lazarus {

static bool match(const unsigned char* data, const char* pattern) {
    const unsigned char* start = data;
    while (*pattern) {
        if (*pattern == ' ') {
            ++pattern;
            continue;
        }
        if (*pattern == '?') {
            if (*(pattern + 1) == '?') {
                pattern += 2;
                ++data;
                continue;
            }
        }
        unsigned int value;
        if (sscanf_s(pattern, "%2x", &value) != 1) {
            return false;
        }
        if (*data != static_cast<unsigned char>(value)) {
            return false;
        }
        pattern += 2;
        ++data;
    }
    return true;
}

void* find_pattern(const char* pattern) {
    MODULEINFO info{};
    if (!GetModuleInformation(GetCurrentProcess(), GetModuleHandle(nullptr), &info, sizeof(info))) {
        log_error("GetModuleInformation failed");
        return nullptr;
    }

    auto* start = static_cast<unsigned char*>(info.lpBaseOfDll);
    auto* end = start + info.SizeOfImage;
    for (auto* ptr = start; ptr < end; ++ptr) {
        if (match(ptr, pattern)) {
            log_info(std::string("Pattern match at ") + std::to_string(reinterpret_cast<uintptr_t>(ptr)));
            return ptr;
        }
    }
    return nullptr;
}

// TODO: Replace these placeholder patterns with verified signatures.
const char* kPatterns[] = {
"""
        for pattern in pattern_lines:
            contents += f'    "{pattern}",\n'
        contents += """};

}
"""
        path.write_text(contents, encoding="utf-8")

    def _write_hooks_header(self, header_path: Path) -> None:
        header_path.write_text(HEADER + "\n" + HOOK_HEADER, encoding="utf-8")

    def _write_hooks_file(
        self,
        hooks_path: Path,
        hook_specs: List[Dict[str, Any]],
    ) -> None:
        lines = [
            HEADER,
            "#include \"hooks.h\"",
            "",
            "#include <MinHook.h>",
            "#include \"logger.h\"",
            "#include \"../instrumentation/packet_logger.h\"",
            "#include \"pattern_scan.cpp\"",
            "",
            "namespace lazarus {",
            "",
        ]

        for spec in hook_specs:
            identifier = spec["identifier"]
            payload_hint = ", ".join(spec.get("payload_fields", [])[:4])
            endpoint = spec.get("endpoint") or "/generated"
            call_conv = spec.get("call_conv", "__stdcall")
            lines.extend(
                [
                    f"// Hook for {spec['description']} (score {spec['score']:.2f})",
                    f"// Endpoint hint: {endpoint}",
                    f"// Payload fields: {payload_hint or 'n/a'}",
                    f"using {identifier}Fn = void({call_conv}*)();",
                    f"static {identifier}Fn g_original_{identifier} = nullptr;",
                    "",
                    f"static void {call_conv} Hook_{identifier}() {{",
                    f"    log_info(\"Hook {identifier} invoked; TODO: inject canonical data\");",
                    "    PacketLogEntry entry{",
                    '        "runtime",',
                    f"        \"{endpoint}\",",
                    "        {},",
                    "    };",
                    "    LogPacket(entry);",
                    f"    if (g_original_{identifier}) {{",
                    f"        g_original_{identifier}();",
                    "    }",
                    "}",
                    "",
                ]
            )

        lines.extend(
            [
                "bool install_hooks() {",
                "    if (MH_Initialize() != MH_OK) {",
                "        log_error(\"MH_Initialize failed\");",
                "        return false;",
                "    }",
            ]
        )

        for spec in hook_specs:
            identifier = spec["identifier"]
            pattern = spec["pattern"]
            lines.extend(
                [
                    f"    if (auto* patternAddr = find_pattern(\"{pattern}\"); patternAddr) {{",
                    "        if (MH_CreateHook(",
                    f"                patternAddr, reinterpret_cast<LPVOID>(Hook_{identifier}),",
                    f"                reinterpret_cast<LPVOID*>(&g_original_{identifier})) != MH_OK) {{",
                    "            log_error(\"MH_CreateHook failed\");",
                    "            return false;",
                    "        }",
                    "        MH_EnableHook(patternAddr);",
                    "    } else {",
                    f"        log_error(\"Pattern not found for {identifier}\");",
                    "    }",
                ]
            )

        lines.extend(
            [
                "    return true;",
                "}",
                "",
                "void remove_hooks() {",
                "    MH_DisableHook(MH_ALL_HOOKS);",
                "    MH_Uninitialize();",
                "}",
                "",
                "} // namespace lazarus",
            ]
        )

        hooks_path.write_text("\n".join(lines), encoding="utf-8")

    def _write_dllmain(self, path: Path) -> None:
        contents = HEADER + """
#include <Windows.h>
#include "logger.h"
#include "hooks/hooks.h"

BOOL APIENTRY DllMain(HMODULE module, DWORD reason, LPVOID reserved) {
    if (reason == DLL_PROCESS_ATTACH) {
        DisableThreadLibraryCalls(module);
        lazarus::log_info("Lazarus generated mod attached.");
        if (!lazarus::install_hooks()) {
            lazarus::log_error("Failed to install hooks.");
        }
    } else if (reason == DLL_PROCESS_DETACH) {
        lazarus::remove_hooks();
        lazarus::log_info("Lazarus generated mod detached.");
    }
    return TRUE;
}
"""
        path.write_text(contents, encoding="utf-8")

    def _build_hook_specs(
        self,
        network_functions: List[Dict[str, object]],
        function_links: List[Dict[str, object]],
    ) -> List[Dict[str, Any]]:
        specs: List[Dict[str, Any]] = []
        scored: List[Dict[str, Any]] = []
        for link in function_links:
            match = next((fn for fn in network_functions if fn.get("name") == link.get("function")), None)
            if not match:
                continue
            specs.append(self._build_spec_from_match(match, link))
        if not specs:
            for fn in network_functions:
                specs.append(self._build_spec_from_match(fn, None))
        if not specs:
            specs.append(
                {
                    "identifier": "fallback_hook",
                    "pattern": "48 8B 05 ?? ?? ?? ??",
                    "description": "Placeholder hook",
                    "imports": "",
                    "endpoint": None,
                    "payload_fields": [],
                    "score": 0.1,
                    "call_conv": "__stdcall",
                }
            )
        scored.extend(specs)
        scored.sort(key=lambda item: item.get("score", 0.0), reverse=True)
        return scored[:4]

    def _build_spec_from_match(
        self,
        fn: Dict[str, object],
        link: Dict[str, object] | None,
    ) -> Dict[str, Any]:
        identifier = self._slugify(fn.get("name", "fn"))
        patterns = fn.get("prologuePatterns") or []
        pattern = patterns[0] if patterns else "48 8B 05 ?? ?? ?? ??"
        imports = ", ".join((fn.get("imports") or [])[:3])
        summary = fn.get("summary") or {}
        pointer_ops = float(summary.get("pointerOps", 0) or 0)
        array_ops = float(summary.get("arrayOps", summary.get("arrayAccesses", 0) or 0))
        score = 0.2 + (pointer_ops * 0.05) + (array_ops * 0.03)
        endpoint = None
        payload_fields: List[str] = []
        http_verbs: List[str] = []
        if link:
            confidence = float(link.get("confidence", 0) or 0)
            score += confidence * 2
            endpoint_strings = link.get("endpointStrings") or link.get("endpoints") or []
            endpoint = endpoint_strings[0] if endpoint_strings else None
            payload_fields = link.get("payloadFields", []) or []
            http_verbs = link.get("httpVerbs", []) or []
        score += self._score_imports(fn.get("imports", []))
        call_conv = fn.get("callingConvention") or "__stdcall"
        description = fn.get("name", "Function")
        if http_verbs:
            description += f" verbs: {', '.join(http_verbs)}"
        return {
            "identifier": identifier,
            "pattern": pattern,
            "description": description,
            "imports": imports,
            "endpoint": endpoint,
            "payload_fields": payload_fields,
            "score": score,
            "call_conv": call_conv,
        }

    def _score_imports(self, imports: List[str]) -> float:
        if not imports:
            return 0.0
        score = 0.0
        for symbol in imports[:5]:
            upper = symbol.upper()
            if any(token in upper for token in ("HTTP", "SOCKET", "WINHTTP", "CURL", "SEND", "RECV")):
                score += 0.5
            elif "TICK" in upper or "UPDATE" in upper:
                score += 0.25
        return score

    def _slugify(self, value: str) -> str:
        slug = "".join(ch.lower() if ch.isalnum() else "_" for ch in value)
        return slug or "hook"

