from __future__ import annotations

import textwrap
import re
from pathlib import Path
from typing import Dict, List

HEADER = "// Generated by Lazarus — review and customize before deployment."

CANONICAL_SCHEMA_TS = textwrap.dedent(
    """\
    import { z } from 'zod';

    const ScalarValue = z.union([
      z.string().max(256),
      z.number().finite(),
      z.boolean(),
      z.null()
    ]);

    export const CanonicalMetadataSchema = z
      .object({
        gameId: z.string().min(1).max(64),
        buildId: z.string().min(1).max(64).optional(),
        locale: z.string().min(2).max(16).optional(),
        createdAt: z.number().int().nonnegative(),
        createdBy: z.string().min(1).max(64).optional()
      })
      .strict();

    export const CanonicalFieldSchema = z
      .object({
        key: z.string().min(1).max(64),
        value: ScalarValue
      })
      .strict();

    export const CanonicalActionSchema = z
      .object({
        name: z.string().min(1).max(64),
        arguments: z.array(CanonicalFieldSchema).max(16).default([])
      })
      .strict();

    export const CanonicalRecordSchema = z
      .object({
        version: z.literal(1),
        recordType: z.string().min(1).max(64),
        recordId: z.string().min(1).max(128),
        metadata: CanonicalMetadataSchema,
        flags: z.array(z.string().min(1).max(32)).max(16).default([]),
        fields: z.array(CanonicalFieldSchema).max(64).default([]),
        actions: z.array(CanonicalActionSchema).max(16).default([])
      })
      .strict();

    export const GeneratedPayloadSchema = z.record(ScalarValue);

    export type CanonicalRecord = z.infer<typeof CanonicalRecordSchema>;
    """
)

SQL_SCHEMA = textwrap.dedent(
    """\
    CREATE TABLE IF NOT EXISTS records (
      id TEXT PRIMARY KEY,
      record_type TEXT NOT NULL,
      version INTEGER NOT NULL,
      created_at INTEGER NOT NULL,
      payload TEXT NOT NULL
    );

    CREATE TABLE IF NOT EXISTS record_flags (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      record_id TEXT NOT NULL,
      flag TEXT NOT NULL,
      FOREIGN KEY (record_id) REFERENCES records(id) ON DELETE CASCADE
    );

    CREATE TABLE IF NOT EXISTS record_fields (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      record_id TEXT NOT NULL,
      field_key TEXT NOT NULL,
      field_value TEXT NOT NULL,
      FOREIGN KEY (record_id) REFERENCES records(id) ON DELETE CASCADE
    );

    CREATE TABLE IF NOT EXISTS record_actions (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      record_id TEXT NOT NULL,
      action_name TEXT NOT NULL,
      arguments_json TEXT NOT NULL,
      FOREIGN KEY (record_id) REFERENCES records(id) ON DELETE CASCADE
    );
    """
)


class BackendGenerator:
    """
    Emits a minimal Fastify + Zod project that mirrors discovered network
    functions as placeholder routes.
    """

    def __init__(self, clean_report: Dict[str, object]) -> None:
        self.report = clean_report

    def generate(self, target_dir: Path) -> Path:
        target_dir = Path(target_dir)
        target_dir.mkdir(parents=True, exist_ok=True)
        (target_dir / "src").mkdir(exist_ok=True)
        (target_dir / "src" / "schema").mkdir(exist_ok=True)
        (target_dir / "src" / "lib").mkdir(exist_ok=True)
        (target_dir / "src" / "db").mkdir(exist_ok=True)
        (target_dir / "src" / "db" / "migrations").mkdir(parents=True, exist_ok=True)
        (target_dir / "src" / "routes").mkdir(exist_ok=True)

        network_functions: List[Dict[str, object]] = self.report.get("networkFunctions", [])  # type: ignore[assignment]
        inferred_fields: List[Dict[str, object]] = self.report.get("inferredPayloadFields", [])  # type: ignore[assignment]
        function_links: List[Dict[str, object]] = self.report.get("functionPayloadLinks", [])  # type: ignore[assignment]
        auth_hints: List[Dict[str, object]] = self.report.get("authHints", [])  # type: ignore[assignment]
        self._write_package_json(target_dir)
        self._write_tsconfig(target_dir)
        self._write_readme(target_dir, network_functions, inferred_fields, auth_hints)
        self._write_schema_file(target_dir / "src" / "schema" / "canonical.ts", inferred_fields)
        self._write_db_client(target_dir / "src" / "db" / "client.ts")
        self._write_migration_runner(target_dir / "src" / "db" / "migrate.ts")
        self._write_migration_file(target_dir / "src" / "db" / "migrations" / "001_init.sql")
        self._write_routes(
            target_dir / "src" / "routes" / "records.ts", network_functions, function_links
        )
        auth_guard_enabled = bool(auth_hints)
        if auth_guard_enabled:
            self._write_auth_guard(target_dir / "src" / "lib" / "auth.ts")
        self._write_server(target_dir / "src" / "server.ts", auth_guard_enabled)
        self._write_payload_helpers(target_dir / "src" / "lib" / "payload.ts", inferred_fields)
        return target_dir

    def _write_package_json(self, target_dir: Path) -> None:
        package_json = {
            "name": "generated-backend",
            "version": "0.1.0",
            "private": True,
            "type": "module",
            "scripts": {
                "dev": "ts-node-dev --respawn src/server.ts",
                "start": "node dist/server.js",
                "build": "tsc -p tsconfig.json",
                "migrate": "ts-node src/db/migrate.ts"
            },
            "dependencies": {
                "fastify": "^4.28.0",
                "zod": "^3.23.8",
                "better-sqlite3": "^9.6.0"
            },
            "devDependencies": {
                "ts-node-dev": "^2.0.0",
                "ts-node": "^10.9.2",
                "typescript": "^5.6.3",
            },
        }
        path = target_dir / "package.json"
        path.write_text(json_dumps(package_json) + "\n", encoding="utf-8")

    def _write_tsconfig(self, target_dir: Path) -> None:
        tsconfig = {
            "compilerOptions": {
                "target": "ES2020",
                "module": "commonjs",
                "outDir": "dist",
                "strict": True,
                "esModuleInterop": True,
                "skipLibCheck": True,
            },
            "include": ["src/**/*.ts"],
        }
        (target_dir / "tsconfig.json").write_text(json_dumps(tsconfig) + "\n", encoding="utf-8")

    def _write_readme(
        self,
        target_dir: Path,
        network_functions: List[Dict[str, object]],
        inferred_fields: List[Dict[str, object]],
        auth_hints: List[Dict[str, object]],
    ) -> None:
        lines = [
            "# Generated Backend Skeleton",
            "",
            "This project was generated by Lazarus. It is intentionally conservative:",
            "",
            "1. Routes are placeholders and must be implemented manually.",
            "2. Canonical Zod schemas live in `src/schema/canonical.ts`.",
            "3. SQLite migrations are in `src/db/migrations/`.",
            "4. Review `analysis_report.json` for canonical data.",
            "",
            "## Candidate endpoints",
        ]
        for fn in network_functions:
            lines.append(f"- `{fn.get('name')}` imports {', '.join(fn.get('imports', []))}")
        lines.append("")

        if inferred_fields:
            lines.extend(
                [
                    "## Inferred payload fields",
                    "",
                    "These fields were auto-discovered via static analysis. Confirm and tighten them before exposing a public API.",
                    "",
                    "| Field | Type | Score | Sources |",
                    "| --- | --- | --- | --- |",
                ]
            )
            for field in inferred_fields[:10]:
                name = field.get("name", "?")
                type_hint = field.get("typeHint") or "string"
                score = field.get("score", 0)
                sources = ", ".join(field.get("sources", [])) or "n/a"
                lines.append(f"| `{name}` | `{type_hint}` | {score} | {sources} |")
            lines.append("")

        lines.append("## Default canonical endpoints")
        lines.append("")
        lines.append("- `GET /records` — list canonical records (optional recordType filter).")
        lines.append("- `GET /records/:id` — fetch a specific canonical record.")
        lines.append("- `POST /records` — write/update a canonical payload.")
        lines.append("- `DELETE /records/:id` — delete a canonical record.")
        if auth_hints:
            lines.append("## Auth hints")
            lines.append("")
            lines.append("Potential secrets/tokens detected during analysis (verify manually):")
            for hint in auth_hints[:5]:
                fn = hint.get("function", "?")
                keywords = ", ".join(hint.get("keywords", []))
                lines.append(f"- `{fn}` keywords: {keywords} (confidence {hint.get('confidence', 0)})")
            lines.append("")

        lines.append("Link to maintainer: https://github.com/lukascollishawm")
        (target_dir / "README.md").write_text(HEADER + "\n\n" + "\n".join(lines), encoding="utf-8")

    def _write_server(self, server_path: Path, enable_auth_guard: bool) -> None:
        auth_import = "import { registerAuthGuard } from './lib/auth';\n" if enable_auth_guard else ""
        auth_registration = "registerAuthGuard(app);\n" if enable_auth_guard else ""
        contents = (
            HEADER
            + "\n"
            + "import Fastify from 'fastify';\n"
            + "import { createDb } from './db/client';\n"
            + "import { registerGeneratedRoutes } from './routes/records';\n"
            + auth_import
            + "\nconst app = Fastify({ logger: true });\n"
            + "const dbPath = process.env.DB_PATH ?? './lazarus.db';\n"
            + "const db = createDb(dbPath);\n\n"
            + "registerGeneratedRoutes(app, db);\n"
        )
        if enable_auth_guard:
            contents += "\n" + auth_registration + "\n"
        contents += textwrap.dedent(
            """
            app.get('/health', async () => ({ status: 'ok' }));

            async function main() {
              await app.listen({ port: Number(process.env.PORT ?? 9000), host: '0.0.0.0' });
            }

            main().catch((err) => {
              app.log.error(err);
              process.exit(1);
            });
            """
        )
        server_path.write_text(contents, encoding="utf-8")

    def _write_schema_file(self, schema_path: Path, inferred_fields: List[Dict[str, object]]) -> None:
        if inferred_fields:
            contents = self._render_inferred_schema(inferred_fields)
        else:
            contents = HEADER + "\n" + CANONICAL_SCHEMA_TS
        schema_path.write_text(contents, encoding="utf-8")

    def _write_payload_helpers(self, helper_path: Path, inferred_fields: List[Dict[str, object]]) -> None:
        default_literal = self._build_ts_default_object(inferred_fields, indent=4)
        contents = (
            HEADER
            + """
import { z } from 'zod';
import { GeneratedPayloadSchema } from '../schema/canonical';

export type GeneratedPayload = z.infer<typeof GeneratedPayloadSchema>;

export function validatePayload(payload: unknown): GeneratedPayload {
  return GeneratedPayloadSchema.parse(payload);
}

export function createDefaultPayload(): GeneratedPayload {
  return """
            + default_literal
            + """ as GeneratedPayload;
}
"""
        )
        helper_path.parent.mkdir(parents=True, exist_ok=True)
        helper_path.write_text(contents, encoding="utf-8")

    def _write_auth_guard(self, guard_path: Path) -> None:
        contents = (
            HEADER
            + """
import { FastifyInstance } from 'fastify';

export function registerAuthGuard(app: FastifyInstance) {
  const expected = process.env.LAZARUS_AUTH_TOKEN;
  if (!expected) {
    app.log.warn('LAZARUS_AUTH_TOKEN not set; auth guard disabled.');
    return;
  }

  app.addHook('preHandler', async (request, reply) => {
    if (process.env.LAZARUS_AUTH_DISABLED === '1') {
      return;
    }
    const header = request.headers['authorization'];
    const requiredHeader = `Bearer ${expected}`;
    if (header !== requiredHeader) {
      reply.code(401).send({ error: 'Unauthorized' });
    }
  });
}
"""
        )
        guard_path.parent.mkdir(parents=True, exist_ok=True)
        guard_path.write_text(contents, encoding="utf-8")

    def _write_db_client(self, client_path: Path) -> None:
        contents = textwrap.dedent(
            """\
            import Database from 'better-sqlite3';
            import { readdirSync, readFileSync } from 'node:fs';
            import { join } from 'node:path';

            export function createDb(path: string) {
              const db = new Database(path);
              db.pragma('journal_mode = WAL');
              applyMigrations(db);
              return db;
            }

            function applyMigrations(db: Database.Database) {
              const migrationsDir = join(__dirname, 'migrations');
              const files = readdirSync(migrationsDir).filter((file) => file.endsWith('.sql')).sort();
              for (const file of files) {
                const sql = readFileSync(join(migrationsDir, file), 'utf-8');
                db.exec(sql);
              }
            }
            """
        )
        client_path.write_text(HEADER + "\n" + contents, encoding="utf-8")

    def _write_migration_runner(self, migrate_path: Path) -> None:
        contents = textwrap.dedent(
            """\
            import { createDb } from './client';

            const dbPath = process.env.DB_PATH ?? './lazarus.db';
            const db = createDb(dbPath);
            db.close();
            console.log(`Migrations applied to ${dbPath}`);
            """
        )
        migrate_path.write_text(HEADER + "\n" + contents, encoding="utf-8")

    def _write_migration_file(self, migration_path: Path) -> None:
        migration_path.write_text(SQL_SCHEMA, encoding="utf-8")

    def _write_routes(
        self,
        routes_path: Path,
        network_functions: List[Dict[str, object]],
        function_links: List[Dict[str, object]],
    ) -> None:
        route_specs = self._build_route_specs(network_functions, function_links)
        route_lines = [
            "import { FastifyInstance } from 'fastify';",
            "import Database from 'better-sqlite3';",
            "import { randomUUID } from 'node:crypto';",
            "import { z } from 'zod';",
            "import { CanonicalRecordSchema, GeneratedPayloadSchema } from '../schema/canonical';",
            "import { validatePayload } from '../lib/payload';",
            "",
            "const IdParams = z.object({ id: z.string().min(1).max(128) });",
            "const ListQuery = z.object({ recordType: z.string().min(1).max(64).optional() });",
            "",
            "type RecordRow = { payload: string };",
            "",
            "function parseRow(row: RecordRow) {",
            "  return CanonicalRecordSchema.parse(JSON.parse(row.payload));",
            "}",
            "",
            "export function registerGeneratedRoutes(app: FastifyInstance, db: Database.Database) {",
            "  const selectRecent = db.prepare('SELECT payload FROM records ORDER BY created_at DESC LIMIT 200');",
            "  const selectByType = db.prepare(",
            "    'SELECT payload FROM records WHERE record_type = ? ORDER BY created_at DESC LIMIT 200'",
            "  );",
            "  const selectById = db.prepare('SELECT payload FROM records WHERE id = ?');",
            "  const insertRecord = db.prepare(`",
            "    INSERT OR REPLACE INTO records",
            "      (id, record_type, version, created_at, payload)",
            "    VALUES (@id, @record_type, @version, @created_at, @payload)",
            "  `);",
            "  const deleteRecord = db.prepare('DELETE FROM records WHERE id = ?');",
            "",
            "  app.get('/records', async (request) => {",
            "    const query = ListQuery.parse(request.query ?? {});",
            "    const rows = query.recordType ? selectByType.all(query.recordType) : selectRecent.all();",
            "    return rows.map((row) => parseRow(row as RecordRow));",
            "  });",
            "",
            "  app.get('/records/:id', async (request, reply) => {",
            "    const params = IdParams.parse(request.params);",
            "    const row = selectById.get(params.id) as RecordRow | undefined;",
            "    if (!row) {",
            "      return reply.code(404).send({ error: 'Not found' });",
            "    }",
            "    return parseRow(row);",
            "  });",
            "",
            "  app.post('/records', async (request) => {",
            "    const incoming = CanonicalRecordSchema.parse(request.body ?? {});",
            "    const metadata = { ...incoming.metadata, createdAt: incoming.metadata?.createdAt ?? Date.now() };",
            "    const normalized = { ...incoming, recordId: incoming.recordId || randomUUID(), metadata };",
            "    insertRecord.run({",
            "      id: normalized.recordId,",
            "      record_type: normalized.recordType,",
            "      version: normalized.version,",
            "      created_at: normalized.metadata.createdAt,",
            "      payload: JSON.stringify(normalized),",
            "    });",
            "    return normalized;",
            "  });",
            "",
            "  app.delete('/records/:id', async (request) => {",
            "    const params = IdParams.parse(request.params);",
            "    deleteRecord.run(params.id);",
            "    return { status: 'deleted', id: params.id };",
            "  });",
            "",
        ]

        for spec in route_specs:
            route_lines.extend(
                [
                    f"  // Derived from {spec['description']}",
                    "  app.route({",
                    f"    method: '{spec['method']}',",
                    f"    url: '{spec['url']}',",
                    "    schema: { body: GeneratedPayloadSchema.optional() },",
                    "    handler: async (request) => ({",
                    f"      note: '{spec['note']}',",
                    "      payload: request.body ? validatePayload(request.body) : undefined,",
                    "      todo: 'Replace with integration logic',",
                    "    }),",
                    "  });",
                    "",
                ]
            )

        route_lines.append("}")
        routes_path.write_text(HEADER + "\n" + "\n".join(route_lines), encoding="utf-8")

    def _build_route_specs(
        self,
        network_functions: List[Dict[str, object]],
        function_links: List[Dict[str, object]],
    ) -> List[Dict[str, str]]:
        specs: List[Dict[str, str]] = []
        used_paths = set()
        for link in function_links[:6]:
            verbs = link.get("httpVerbs", []) or ["GET"]
            method = verbs[0].upper()
            endpoints = link.get("endpoints", []) or []
            path = self._normalize_endpoint(endpoints[0]) if endpoints else ""
            if not path:
                path = f"/generated/{self._slugify(link.get('function', 'endpoint'))}"
            if path in used_paths:
                continue
            used_paths.add(path)
            specs.append(
                {
                    "method": method,
                    "url": self._append_params(path, link.get("payloadFields", [])),
                    "description": f"{link.get('function')} (confidence {link.get('confidence', 0)})",
                    "note": "Auto-derived from request/response hints.",
                }
            )
        if len(specs) < 3:
            for idx, fn in enumerate(network_functions[:5]):
                name = fn.get("name") or f"function_{idx}"
                slug = self._slugify(name)
                url = f"/generated/{slug}"
                if url in used_paths:
                    continue
                specs.append(
                    {
                        "method": "GET",
                        "url": url,
                        "description": f"{name} (imports: {', '.join(fn.get('imports', []))})",
                        "note": "Investigate this function to replicate behavior.",
                    }
                )
                used_paths.add(url)
        if not specs:
            specs.append(
                {
                    "method": "GET",
                    "url": "/generated/example",
                    "description": "Placeholder route",
                    "note": "Populate this route with backend logic.",
                }
            )
        return specs

    def _slugify(self, value: str) -> str:
        slug = "".join(ch.lower() if ch.isalnum() else "-" for ch in value)
        while "--" in slug:
            slug = slug.replace("--", "-")
        return slug.strip("-") or "route"

    def _normalize_endpoint(self, endpoint: str) -> str:
        cleaned = endpoint.strip()
        if not cleaned:
            return ""
        if cleaned.startswith("http://") or cleaned.startswith("https://"):
            parts = cleaned.split("/", 3)
            if len(parts) >= 4:
                cleaned = "/" + parts[3]
            else:
                cleaned = "/"
        if not cleaned.startswith("/"):
            cleaned = "/" + cleaned
        cleaned = cleaned.split("?")[0]
        while "//" in cleaned:
            cleaned = cleaned.replace("//", "/")
        return cleaned or "/"

    def _append_params(self, path: str, payload_fields: List[str]) -> str:
        if not payload_fields:
            return path
        candidates = [field for field in payload_fields if field and field.lower().endswith("id")]
        if not candidates:
            return path
        suffix = "".join(f"/:{self._param_name(field)}" for field in candidates[:2])
        base = path.rstrip("/")
        return (base or "/") + suffix

    def _param_name(self, name: str) -> str:
        cleaned = "".join(ch if ch.isalnum() else "_" for ch in name)
        cleaned = cleaned.strip("_")
        if not cleaned:
            return "id"
        if cleaned[0].isdigit():
            cleaned = f"id_{cleaned}"
        return cleaned.lower()

    def _build_ts_default_object(self, fields: List[Dict[str, object]], indent: int = 2) -> str:
        if not fields:
            return "{}"
        indent_str = " " * indent
        closing_indent = " " * (indent - 2) if indent >= 2 else ""
        lines = ["{"]
        for field in fields[:32]:
            prop = self._format_property_name(str(field.get("name", "field")))
            value = self._default_value_expr(field, indent + 2)
            if "\n" in value:
                value = value.replace("\n", f"\n{' ' * (indent + 2)}")
            lines.append(f"{indent_str}{prop}: {value},")
        lines.append(f"{closing_indent}}}")
        return "\n".join(lines)

    def _default_value_expr(self, field: Dict[str, object], indent: int) -> str:
        type_hint = (field.get("typeHint") or "").lower()
        children = field.get("children") or []
        if type_hint == "boolean":
            return "false"
        if type_hint == "number":
            return "0"
        if type_hint == "object":
            if children:
                return self._build_ts_default_object(children, indent)
            return "{}"
        if type_hint == "array":
            return "[]"
        return '""'

    def _render_inferred_schema(self, inferred_fields: List[Dict[str, object]]) -> str:
        lines: List[str] = [HEADER, "", "import { z } from 'zod';", ""]
        lines.extend(
            [
                "const ScalarValue = z.union([",
                "  z.string().max(256),",
                "  z.number().finite(),",
                "  z.boolean(),",
                "  z.null()",
                "]);",
                "",
                "export const GeneratedPayloadSchema = z",
                "  .object({",
            ]
        )
        if not inferred_fields:
            lines.append("  // No fields inferred; fallback to loose payload.")
        for field in inferred_fields[:32]:
            lines.extend(self._render_field_line(field))
        lines.extend(
            [
                "  })",
                "  .strict();",
                "",
                "export const CanonicalFieldSchema = z",
                "  .object({",
                "    key: z.string().min(1).max(64),",
                "    value: ScalarValue",
                "  })",
                "  .strict();",
                "",
                "export const CanonicalActionSchema = z",
                "  .object({",
                "    name: z.string().min(1).max(64),",
                "    arguments: z.array(CanonicalFieldSchema).max(16).default([])",
                "  })",
                "  .strict();",
                "",
                "export const CanonicalRecordSchema = z",
                "  .object({",
                "    version: z.literal(1),",
                "    recordType: z.string().min(1).max(64),",
                "    recordId: z.string().min(1).max(128),",
                "    metadata: z",
                "      .object({",
                "        gameId: z.string().min(1).max(64),",
                "        buildId: z.string().min(1).max(64).optional(),",
                "        locale: z.string().min(2).max(16).optional(),",
                "        createdAt: z.number().int().nonnegative(),",
                "        createdBy: z.string().min(1).max(64).optional()",
                "      })",
                "      .strict(),",
                "    flags: z.array(z.string().min(1).max(32)).max(16).default([]),",
                "    fields: z.array(CanonicalFieldSchema).max(64).default([]),",
                "    actions: z.array(CanonicalActionSchema).max(16).default([]),",
                "    payload: GeneratedPayloadSchema.optional()",
                "  })",
                "  .strict();",
                "",
                "export type CanonicalRecord = z.infer<typeof CanonicalRecordSchema>;",
                "export type GeneratedPayload = z.infer<typeof GeneratedPayloadSchema>;",
            ]
        )
        return "\n".join(lines)

    def _render_field_line(self, field: Dict[str, object]) -> List[str]:
        name = str(field.get("name", "field"))
        score = field.get("score", 0)
        sources = ", ".join(field.get("sources", [])[:3])
        comment = f"  // score={score}"
        if sources:
            comment += f" sources={sources}"
        prop = self._format_property_name(name)
        schema = self._build_field_schema(field)
        schema = schema.replace("\n", "\n  ")
        return [
            comment,
            f"  {prop}: {schema}.optional(),",
        ]

    def _format_property_name(self, value: str) -> str:
        if re.match(r"^[A-Za-z_][A-Za-z0-9_]*$", value):
            return value
        return f"'{value}'"

    def _build_field_schema(self, field: Dict[str, object], indent: int = 2) -> str:
        type_hint = (field.get("typeHint") or "").lower()
        name = str(field.get("name", "field"))
        children = field.get("children") or []
        indent_str = " " * indent
        if type_hint == "object" and children:
            inner_lines = []
            for child in children[:16]:
                child_schema = self._build_field_schema(child, indent + 2)
                child_prop = self._format_property_name(child.get("name", "field"))
                child_schema = child_schema.replace("\n", f"\n{indent_str}    ")
                inner_lines.append(f"{indent_str}  {child_prop}: {child_schema}.optional(),")
            if not inner_lines:
                return "z.object({}).strict()"
            return "z.object({\n" + "\n".join(inner_lines) + f"\n{indent_str}}}).strict()"
        if type_hint == "array":
            if children:
                element_schema = self._build_field_schema(children[0], indent + 2)
                element_schema = element_schema.replace("\n", f"\n{indent_str}  ")
                return f"z.array({element_schema}).max(32)"
            return "z.array(ScalarValue).max(32)"
        if type_hint:
            return self._zod_type_from_hint(type_hint)
        return self._infer_field_type(name)

    def _infer_field_type(self, name: str) -> str:
        lowered = name.lower()
        bool_prefixes = ("is", "has", "can", "should", "enable", "allow", "use", "needs")
        number_tokens = (
            "count",
            "num",
            "total",
            "time",
            "rank",
            "score",
            "size",
            "limit",
            "length",
            "seconds",
            "minutes",
            "ms",
            "amount",
            "level",
            "index",
            "timestamp",
            "duration",
        )
        if lowered.startswith(bool_prefixes):
            return "z.boolean()"
        if any(token in lowered for token in number_tokens):
            return "z.number().int().nonnegative()"
        if lowered.endswith("id") or "uuid" in lowered or lowered.endswith("guid"):
            return "z.string().min(1).max(64)"
        if "date" in lowered:
            return "z.number().int().nonnegative()"
        return "z.string().min(1).max(256)"

    def _zod_type_from_hint(self, hint: str) -> str:
        normalized = hint.lower()
        if normalized == "boolean":
            return "z.boolean()"
        if normalized == "number":
            return "z.number().finite()"
        if normalized == "array":
            return "z.array(ScalarValue).max(32)"
        if normalized == "object":
            return "z.record(ScalarValue)"
        return "z.string().min(1).max(256)"


def json_dumps(obj: Dict[str, object]) -> str:
    import json

    return json.dumps(obj, indent=2, sort_keys=True)

